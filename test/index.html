<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8" />
	<title>AjLisp Test Suite</title>
	<link rel="stylesheet" href="qunit.css" type="text/css" media="screen">
	<script type="text/javascript" src="../src/ajlisp.js"></script>
	<script type="text/javascript" src="../dependencies/jquery-1.6.2.min.js"></script>
	<script type="text/javascript" src="qunit.js"></script>
</head>
<body>
	<h1 id="qunit-header">AjLisp Test Suite</h1>
	<h2 id="qunit-banner"></h2>
	<div id="qunit-testrunner-toolbar"></div>
	<h2 id="qunit-userAgent"></h2>
	<ol id="qunit-tests"></ol>
	<div id="qunit-fixture">test markup</div>
	
<div id="mapfirst" style="display: none">
(define mapfirst (fn lst)
  (if (nilp lst)
    nil
    (cons
      (fn (first lst))
      (mapfirst fn (rest lst))
    )
  )
)
</div>	

<div id="append" style="display: none">
(define append (x y) (if (nilp x) y (cons (first x) (append (rest x) y))))
</div>	

<div id="mapcond" style="display: none">
(define mapcond (fn lst)
	(if (nilp lst)
		nil
		(if (fn (first lst))
			(cons 
				(first lst) 
				(mapcond fn (rest lst))
			)
			(mapcond fn (rest lst))
		)
	)
)
</div>	

<script type="text/javascript">
	$(function() {
		test("First Test", function() {
			same(3-1,2);
		});
		
		test("AjLisp namespace", function() {
			notEqual(AjLisp, undefined);
		});
		
		test("List", function() {
			var list = new AjLisp.List(1,2);
			equals(list.first(), 1);
			equals(list.rest(), 2);
			equal(list.isAtom(),false);
			equal(list.isList(),true);
			equal(AjLisp.isAtom(list), false);
			equal(AjLisp.isList(list), true);
			equal(list.asString(), "(1.2)");
			equal(list.equals(list), true);
			var list2 = new AjLisp.List(1,2);
			equal(list.equals(list2), true);
			equal(list2.equals(list), true);
			var list3 = AjLisp.makeList(1,2,3);
			equal(list.equals(list3), false);
			equal(list3.equals(list), false);
		});
		
		test("Object Evaluate", function() {
			var environment = new AjLisp.Environment();
			var n = 1;
			equals(AjLisp.evaluate(n, environment), 1);
			var m = 2;
			equal(AjLisp.evaluate(m, environment), 2);
			equal(AjLisp.evaluate("foo", environment), "foo");
		});
		
		test("Top Environment", function() {
			notEqual(AjLisp.environment, undefined);
		});
		
		test("Environment", function() {
			var environment = new AjLisp.Environment();
			equal(environment.parent(), null);
			equal(environment.getValue("a"), undefined);
			environment.setValue("one", 1);
			equal(environment.getValue("one"), 1);
		});
		
		test("Parent Environment", function() {
			var parent = new AjLisp.Environment();
			var environment = new AjLisp.Environment(parent);
			equal(environment.parent(), parent);
			equal(parent.parent(), null);
			equal(environment.getValue("a"), undefined);
			environment.setValue("one", 1);
			equal(environment.getValue("one"), 1);
			parent.setValue("two", 2);
			equal(environment.getValue("two"), 2);
			environment.setValue("two", 3);
			equal(environment.getValue("two"), 3);
			equal(parent.getValue("two"), 2);
		});
		
		test("Atom", function() {
			var environment = new AjLisp.Environment();
			environment.setValue("one", 1);
			var one = new AjLisp.Atom("one");
			equal(one.evaluate(environment), 1);
			ok(one.isAtom());
			equal(one.isList(), false);
			ok(AjLisp.isAtom(one));
			equal(AjLisp.isList(one), false);
			equal(one.asString(), "one");
			equal(one.equals(one), true);
			var one2 = new AjLisp.Atom("one");
			equal(one.equals(one2), true);
		});
		
		test("ListForm simple apply", function() {
			var list = new AjLisp.List(AjLisp.environment.list, new AjLisp.List(1, null));			
			var result = AjLisp.environment.list.apply(list);			
			equal(result.first(), 1);
			equal(result.rest(), null);			
			var result2 = list.evaluate(null);			
			equal(result2.first(), 1);
			equal(result2.rest(), null);
		});
		
		test("FirstForm simple apply", function() {
			var list = AjLisp.makeList(AjLisp.environment.first, AjLisp.makeList(AjLisp.environment.list, 1));
			var result = AjLisp.environment.first.apply(list);			
			equal(result, 1);			
			var result2 = list.evaluate(null);			
			equal(result2, 1);
		});
		
		test("RestForm simple apply", function() {
			var list = AjLisp.makeList(AjLisp.environment.rest, AjLisp.makeList(AjLisp.environment.list, 1));
			var result = AjLisp.environment.rest.apply(list);			
			equal(result, null);			
			var result2 = list.evaluate(null);			
			equal(result2, null);
		});
		
		test("MakeList", function() {
			var list = AjLisp.makeList(1,2,3);
			equal(list.asString(), "(1 2 3)");
			
			equal(list.first(), 1);
			equal(list.rest().first(), 2);
			equal(list.rest().rest().first(), 3);
			equal(list.rest().rest().rest(), null);
		});
		
		test("Define", function() {
			var list = AjLisp.makeList(AjLisp.environment.define, new AjLisp.Atom("one"), 1);
			equal(list.evaluate(AjLisp.environment), 1);
			equal(AjLisp.environment.one, 1);
		});
		
		test("Do", function() {
			var list1 = AjLisp.makeList(AjLisp.environment.define, new AjLisp.Atom("one"), 1);
			var list2 = AjLisp.makeList(AjLisp.environment.define, new AjLisp.Atom("two"), 2);
			var list3 = AjLisp.makeList(AjLisp.environment.define, new AjLisp.Atom("three"), 3);
			var list = AjLisp.makeList(AjLisp.environment.do, list1, list2, list3);
			equal(list.evaluate(AjLisp.environment), 3);
			equal(AjLisp.environment.one, 1);
			equal(AjLisp.environment.two, 2);
			equal(AjLisp.environment.three, 3);
		});
		
		test("Closure without parameters", function() {
			var list1 = AjLisp.makeList(AjLisp.environment.define, new AjLisp.Atom("one"), 1);
			var list2 = AjLisp.makeList(AjLisp.environment.define, new AjLisp.Atom("two"), 2);
			var list3 = AjLisp.makeList(AjLisp.environment.define, new AjLisp.Atom("three"), 3);
			var body = AjLisp.makeList(list1, list2, list3);
			var closure = new AjLisp.Closure(null, AjLisp.environment, body);
			equal(closure.apply(null, AjLisp.environment), 3);
			equal(AjLisp.environment.one, 1);
			equal(AjLisp.environment.two, 2);
			equal(AjLisp.environment.three, 3);
		});
		
		test("Closure with parameters", function() {
			var list1 = AjLisp.makeList(AjLisp.environment.define, new AjLisp.Atom("one"), new AjLisp.Atom("a"));
			var list2 = AjLisp.makeList(AjLisp.environment.define, new AjLisp.Atom("two"), new AjLisp.Atom("b"));
			var list3 = AjLisp.makeList(AjLisp.environment.define, new AjLisp.Atom("three"), new AjLisp.Atom("c"));
			var body = AjLisp.makeList(list1, list2, list3);
			var names = AjLisp.makeList(new AjLisp.Atom("a"), new AjLisp.Atom("b"), new AjLisp.Atom("c"));
			var closure = new AjLisp.Closure(names, AjLisp.environment, body);
			var list = AjLisp.makeList(closure,1,2,3);
			equal(list.evaluate(AjLisp.environment), 3);
			equal(AjLisp.environment.one, 1);
			equal(AjLisp.environment.two, 2);
			equal(AjLisp.environment.three, 3);
		});
		
		test("Lambda with parameters", function() {
			var list1 = AjLisp.makeList(AjLisp.environment.define, new AjLisp.Atom("one"), new AjLisp.Atom("a"));
			var list2 = AjLisp.makeList(AjLisp.environment.define, new AjLisp.Atom("two"), new AjLisp.Atom("b"));
			var list3 = AjLisp.makeList(AjLisp.environment.define, new AjLisp.Atom("three"), new AjLisp.Atom("c"));
			var names = AjLisp.makeList(new AjLisp.Atom("a"), new AjLisp.Atom("b"), new AjLisp.Atom("c"));
			var lambda = AjLisp.makeList(AjLisp.environment.lambda, names, list1, list2, list3);
			var list = AjLisp.makeList(lambda,1,2,3);
			equal(list.evaluate(AjLisp.environment), 3);
			equal(AjLisp.environment.one, 1);
			equal(AjLisp.environment.two, 2);
			equal(AjLisp.environment.three, 3);
		});
		
		test("Lexer Simple Token", function() {
			var lexer;
			var token;
			
			lexer = new AjLisp.Lexer("");
			equal(lexer.nextToken(), null);

			lexer = new AjLisp.Lexer("a");
			token = lexer.nextToken();
			notEqual(token, null);
			equal(token.value, "a");
			equal(token.type, AjLisp.TokenType.Name);

			lexer = new AjLisp.Lexer("name");
			token = lexer.nextToken();
			notEqual(token, null);
			equal(token.value, "name");
			equal(token.type, AjLisp.TokenType.Name);

			lexer = new AjLisp.Lexer("name2");
			token = lexer.nextToken();
			notEqual(token, null);
			equal(token.value, "name2");
			equal(token.type, AjLisp.TokenType.Name);

			lexer = new AjLisp.Lexer("'");
			token = lexer.nextToken();
			notEqual(token, null);
			equal(token.value, "'");
			equal(token.type, AjLisp.TokenType.Name);

			lexer = new AjLisp.Lexer("123");
			token = lexer.nextToken();
			notEqual(token, null);
			equal(token.value, 123);
			equal(token.type, AjLisp.TokenType.Number);

			lexer = new AjLisp.Lexer("123.45");
			token = lexer.nextToken();
			notEqual(token, null);
			equal(token.value, 123.45);
			equal(token.type, AjLisp.TokenType.Number);
			equal(typeof (token.value), "number");

			lexer = new AjLisp.Lexer("(");
			token = lexer.nextToken();
			notEqual(token, null);
			equal(token.value, "(");
			equal(token.type, AjLisp.TokenType.Separator);
		});
		
		test("Lexer Multiple Tokens", function() {
			var lexer;
			var token;
			
			lexer = new AjLisp.Lexer("(list 1 2 3)");
			
			token = lexer.nextToken();
			isSeparator(token, "(");
			token = lexer.nextToken();
			isName(token, "list");
			token = lexer.nextToken();
			isNumber(token, 1);
			token = lexer.nextToken();
			isNumber(token, 2);
			token = lexer.nextToken();
			isNumber(token, 3);
			token = lexer.nextToken();
			isSeparator(token, ")");
			token = lexer.nextToken();
			equal(token, null);
			
			function isSeparator(token, expected) {
				return isToken(token, expected, AjLisp.TokenType.Separator);
			}
			
			function isName(token, expected) {
				return isToken(token, expected, AjLisp.TokenType.Name);
			}
			
			function isNumber(token, expected) {
				equal(typeof token.value, "number");
				return isToken(token, expected, AjLisp.TokenType.Number);
			}
			
			function isToken(token, value, type) {
				notEqual(token, null);
				equal(token.value, value);
				equal(token.type, type);
			}
		});

		test("Parser", function() {
			var lexer;
			var parser;
			var expr;
			
			lexer = new AjLisp.Lexer("a");
			parser = new AjLisp.Parser(lexer);
			
			expr = parser.parse();
			
			notEqual(expr, null);
			equal(expr.isAtom(), true);
			
			lexer = new AjLisp.Lexer("(1 2 3)");
			parser = new AjLisp.Parser(lexer);
			
			expr = parser.parse();
			
			notEqual(expr, null);
			equal(expr.isList(), true);
			equal(expr.asString(), "(1 2 3)");
			
			lexer = new AjLisp.Lexer("(list (add 1 2 3) a b c)");
			parser = new AjLisp.Parser(lexer);
			
			expr = parser.parse();
			
			notEqual(expr, null);
			equal(expr.isList(), true);
			equal(expr.asString(), "(list (add 1 2 3) a b c)");
			
			lexer = new AjLisp.Lexer("nil");
			parser = new AjLisp.Parser(lexer);
			
			expr = parser.parse();
			
			equal(expr, null);

			lexer = new AjLisp.Lexer("false");
			parser = new AjLisp.Parser(lexer);
			
			expr = parser.parse();
			
			equal(expr, false);

			lexer = new AjLisp.Lexer("true");
			parser = new AjLisp.Parser(lexer);
			
			expr = parser.parse();
			
			equal(expr, true);

			lexer = new AjLisp.Lexer("(nil nil nil)");
			parser = new AjLisp.Parser(lexer);
			
			expr = parser.parse();
			
			notEqual(expr, null);
			equal(expr.isList(), true);
			equal(expr.asString(), "(nil nil nil)");

			lexer = new AjLisp.Lexer($("#mapfirst").html());
			parser = new AjLisp.Parser(lexer);
			
			expr = parser.parse();
		});

		test("Parse Quote", function() {
			var lexer;
			var parser;
			var expr;
			
			lexer = new AjLisp.Lexer("'a");
			parser = new AjLisp.Parser(lexer);
			
			expr = parser.parse();
			
			equal(expr.asString(), "'a");
			
			lexer = new AjLisp.Lexer("(quote a)");
			parser = new AjLisp.Parser(lexer);
			
			expr = parser.parse();
			
			equal(expr.asString(), "'a");
		});
		
		test("Evaluate Simple Expression", function() {
			equal(eval("1"), 1);
			equal(eval("(quote (1 2 3))").asString(), "(1 2 3)");
			equal(eval("(list 1 2 3)").asString(), "(1 2 3)");
			equal(eval("(first (list 1 2 3))"), 1);
			equal(eval("(rest (list 1 2 3))").asString(), "(2 3)");
			equal(eval("(cons 1 (list 2 3))").asString(), "(1 2 3)");
			equal(eval("(cons 1 (list 2 3))").asString(), "(1 2 3)");			
			equal(eval("(cons 1 nil)").asString(), "(1)");			
			equal(eval("(cons 1)").asString(), "(1)");			
		});
		
		test("Evaluate Simple Expression with Atoms", function() {
			eval("(define one 1)");
			eval("(define two 2)");
			eval("(define three 3)");
			equal(eval("one"), 1);
			equal(eval("(quote one)").asString(), "one");
			equal(eval("(list one two three)").asString(), "(1 2 3)");
			equal(eval("(first (list one two three))"), 1);
			equal(eval("(rest (list one two three))").asString(), "(2 3)");
			equal(eval("(cons one (list two three))").asString(), "(1 2 3)");
		});
		
		test("Evaluate Let", function() {
			equal(eval("(let ((a 1) (b 2) (c 3)) (list a b c))").asString(), "(1 2 3)");
		});
		
		test("Evaluate Predicates", function() {
			equal(eval("(nilp)"), true);
			equal(eval("(listp)"), true);
			equal(eval("(nilp 1)"), false);
			equal(eval("(listp 1)"), false);
			equal(eval("(nilp (list 1 2 3))"), false);
			equal(eval("(listp (list 1 2 3))"), true);
		});

		test("Evaluate mapfirst", function() {
			eval($("#mapfirst").html());
			equal(eval("(mapfirst list (list 1 2 3))").asString(), "((1) (2) (3))");
			equal(eval("(mapfirst first (quote ((1) (2) (3))))").asString(), "(1 2 3)");
		});

		test("Evaluate append", function() {
			eval($("#append").html());
			equal(eval("(append (list 1 2) (list 3 4 5))").asString(), "(1 2 3 4 5)");
			equal(eval("(append (list 1 2) nil)").asString(), "(1 2)");
		});

		test("Evaluate mapcond", function() {
			eval($("#mapcond").html());
			equal(eval("(mapcond listp (list 1 (list 2) 3))").asString(), "((2))");
			equal(eval("(mapcond nilp (list 1 nil 3))").asString(), "(nil)");
		});
		
		test("Flambda", function() {
			equal(eval("((flambda (x) x) y)").asString(), "y");
			eval("(define myquote (flambda (x) x))");
			equal(eval("(myquote (x y))").asString(), "(x y)");
		});
		
		test("Mlambda", function() {
			equal(eval("((mlambda (x) (list 'quote x)) y)").asString(), "y");
			equal(eval("(let ((z '(a b))) ((mlambda (x) (cons 'first (cons x))) z))").asString(), "a");
			eval("(define definef (mlambda x (list 'define (first x) (cons 'flambda (rest x)))))");
			eval("(definef myquote (x) x)");
			equal(eval("(myquote x)").asString(), "x");
			eval("(define definem (mlambda x (list 'define (first x) (cons 'mlambda (rest x)))))");
			eval("(definem myquote2 (x) (list 'quote x))");
			equal(eval("(myquote2 x)").asString(), "x");
			equal(eval("(myquote2 (1 2 3))").asString(), "(1 2 3)");
			eval("(definem myfirst (x) (list 'first x))");
			equal(eval("(myfirst '(a b c))").asString(), "a");
			eval("(definem apply (fn args) (cons fn args))");
			equal(eval("(apply list ('a 'b 'c))").asString(), "(a b c)");
			equal(eval("(apply rest ('(a b c)))").asString(), "(b c)");
			equal(eval("(apply (first (list rest list)) ('(a b c)))").asString(), "(b c)");
			eval("(definem cond lst (if (nilp lst) nil (list 'if (first (first lst)) (cons 'do (rest (first lst))) (cons 'cond (rest lst)))))");
			equal(eval("(cond)"), null);
			equal(eval("(cond (true 'a))").asString(), "a");
			equal(eval("(cond (nil 'a))"), null);
			equal(eval("(cond (nil 'a) (true 'b))").asString(), "b");
			equal(eval("(cond (nil 'a) (true 'b 'c))").asString(), "c");
			eval("(define atomp (x) (cond ((nilp x) true) ((listp x) false) (true true)))");
			equal(eval("(atomp nil)"), true);
			equal(eval("(atomp 'a)"), true);
			equal(eval("(atomp '(a b))"), false);
		});
		
		test("Equalp", function() {
			equal(eval("(equalp 'one 'one)"), true);
			equal(eval("(equalp '(1 2 3) '(1 2 3))"), true);
			equal(eval("(equalp 'one 'two)"), false);
			equal(eval("(equalp '(1 2 3) '(1 2 3 4))"), false);
			equal(eval("(equalp '(1 2 3 4) '(1 2 3))"), false);
			equal(eval("(equalp 1 1)"), true);
			equal(eval("(equalp 1 2)"), false);
		});
		
		function eval(text) {
			var lexer = new AjLisp.Lexer(text);
			var parser = new AjLisp.Parser(lexer);
			var expr = parser.parse();
			equal(parser.parse(), null);
			return AjLisp.evaluate(expr, AjLisp.environment);
		}
	});
</script>
</body>
</html>
